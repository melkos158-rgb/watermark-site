<!DOCTYPE html>
<html lang="uk">
<head>
  <meta charset="utf-8" />
  <title>Online Tools — STL/3D</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link rel="stylesheet" href="{{ url_for('static', filename='style.css') }}">

  <!-- Лише мінімальні стилі під вʼювер -->
  <style>
    /* контейнер під three.js */
    #viewer{
      width:100%;
      height:62vh;          /* адаптивно */
      min-height:420px;     /* щоб не стискався занадто */
      background:#111;
      border:1px solid #e1e5ee;
      border-radius:10px;
      overflow:hidden;
    }
    #viewer canvas{display:block;width:100%;height:100%;}
    .row{display:flex;gap:8px;flex-wrap:wrap}
    .hint{font-size:12px;color:#667085;margin-top:6px}
    hr{border:none;border-top:1px solid #e9ecf2;margin:10px 0}
  </style>

  <!-- importmap: фіксує модулі, щоб не було "Failed to resolve module specifier 'three'" -->
  <script type="importmap">
  {
    "imports": {
      "three": "https://cdn.jsdelivr.net/npm/three@0.159/build/three.module.js",
      "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.159/examples/jsm/",
      "stl/loader": "https://cdn.jsdelivr.net/npm/three@0.159/examples/jsm/loaders/STLLoader.js",
      "stl/exporter": "https://cdn.jsdelivr.net/npm/three@0.159/examples/jsm/exporters/STLExporter.js",
      "font/loader": "https://cdn.jsdelivr.net/npm/three@0.159/examples/jsm/loaders/FontLoader.js",
      "text/geometry": "https://cdn.jsdelivr.net/npm/three@0.159/examples/jsm/geometries/TextGeometry.js"
    }
  }
  </script>
</head>
<body>

 <!-- NAV -->
 {% include 'nav.html' %}



  <!-- Основна сітка (твоя .layout + .card) -->
  <div class="layout">

    <!-- Ліва колонка -->
    <div class="card side">
      <h2>Модель</h2>

      <label>STL файл</label>
      <input id="file" type="file" accept=".stl">
      <p class="help">Перетягни файл у перегляд або вибери тут.</p>

      <div class="row" style="margin-top:10px">
        <button id="btnDemo"  class="btn primary">Демо куб</button>
        <button id="btnReset" class="btn ghost">Ресет камери</button>
      </div>

      <div class="row">
        <button id="btnWire" class="btn ghost">Wireframe ON/OFF</button>
        <button id="btnClear" class="btn ghost">Очистити</button>
      </div>

      <p class="help">Керування: ЛКМ — обертати, колесо — зум, Shift+ЛКМ — панорамувати.</p>
    </div>

    <!-- Центр -->
    <div class="card">
      <h2>Перегляд</h2>
      <div id="viewer"></div>
      <div class="hint" id="status"></div>
    </div>

    <!-- Права колонка -->
    <div class="card side">
      <h2>Авторство</h2>

      <label for="author">Автор (для ASCII STL)</label>
      <input id="author" type="text" placeholder="© My Brand" value="© My Brand">

      <label style="margin-top:8px">
        <input id="metaToggle" type="checkbox" checked>
        Додавати «змінне» авторство у назву <code>solid</code> (ASCII STL)
      </label>

      <hr>

      <h2 style="margin-top:0">3D водяний знак</h2>

      <label for="wmText">Текст</label>
      <input id="wmText" type="text" placeholder="Brand" value="Brand">

      <label for="wmSize">Розмір тексту</label>
      <input id="wmSize" type="range" min="2" max="40" value="12">

      <label for="wmDepth">Глибина (мм)</label>
      <input id="wmDepth" type="range" min="1" max="10" value="3">

      <label for="wmAngle">Кут (°)</label>
      <input id="wmAngle" type="range" min="-90" max="90" value="0">

      <label for="wmOffset">Відступ від країв (%)</label>
      <input id="wmOffset" type="range" min="0" max="20" value="4">

      <div class="row" style="margin-top:8px">
        <button id="btnPreview" class="btn ghost">Попередній перегляд</button>
        <button id="btnBake" class="btn ghost" disabled>Запекти в модель</button>
      </div>

      <hr>

      <div class="row">
        <button id="btnExportAscii" class="btn primary">Експорт STL (ASCII)</button>
        <button id="btnExportBinary" class="btn ghost">Експорт STL (Binary)</button>
      </div>

      <p class="help">ASCII STL може містити помітне в назві <code>solid</code> (автор). Binary STL зазвичай метадані обрізає.</p>
    </div>
  </div>

  <!-- JS (модулі через importmap) -->
  <script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
    import { STLLoader }     from 'stl/loader';
    import { STLExporter }   from 'stl/exporter';
    import { FontLoader }    from 'font/loader';
    import { TextGeometry }  from 'text/geometry';

    const $ = (id)=>document.getElementById(id);
    const statusEl = $('status');

    // ---- Сцена
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x111111);

    const camera = new THREE.PerspectiveCamera(50, 1, 0.01, 1000);
    camera.position.set(1.2, 0.9, 1.8);

    const renderer = new THREE.WebGLRenderer({ antialias:true });
    renderer.outputColorSpace = THREE.SRGBColorSpace;
    renderer.setPixelRatio(Math.min(window.devicePixelRatio||1, 2));
    $('viewer').appendChild(renderer.domElement);

    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;

    // Світло + сітка
    scene.add(new THREE.AmbientLight(0xffffff, 0.7));
    const dir = new THREE.DirectionalLight(0xffffff, 0.9);
    dir.position.set(2,2,2); scene.add(dir);
    const grid = new THREE.GridHelper(10, 10, 0x3a4153, 0x262b39);
    grid.position.y = -0.001; scene.add(grid);

    // Групи
    const modelRoot = new THREE.Group(); scene.add(modelRoot);
    const watermarkGroup = new THREE.Group(); scene.add(watermarkGroup);

    // Матеріали
    const baseMaterial = new THREE.MeshStandardMaterial({ color:0x9aa7c7, roughness:.85, metalness:.05 });
    const wireMaterial = new THREE.MeshBasicMaterial({ color:0xffffff, wireframe:true });
    let wireframeOn = false;

    // Ресайз
    function resize(){
      const cont = $('viewer');
      const w = cont.clientWidth || cont.parentElement.clientWidth || 800;
      const h = cont.clientHeight || Math.max(420, Math.round(w*0.62));
      renderer.setSize(w,h,false);
      camera.aspect = w/h;
      camera.updateProjectionMatrix();
    }
    new ResizeObserver(resize).observe($('viewer')); window.addEventListener('resize', resize); resize();

    function fitCameraToObject(object, zoom=1.6){
      const box = new THREE.Box3().setFromObject(object);
      const size = box.getSize(new THREE.Vector3());
      const center = box.getCenter(new THREE.Vector3());
      const maxDim = Math.max(size.x, size.y, size.z) || 1;
      const fov = camera.fov * (Math.PI/180);
      let camZ = Math.abs(maxDim / (2*Math.tan(fov/2))) * zoom;
      camZ = Math.max(camZ, 0.1);
      camera.position.set(center.x+camZ*0.7, center.y+camZ*0.5, center.z+camZ);
      camera.near = camZ/100; camera.far = camZ*100; camera.updateProjectionMatrix();
      controls.target.copy(center); controls.update();
    }
    function resetCamera(){
      if (modelRoot.children.length) fitCameraToObject(modelRoot, 1.6);
      else { camera.position.set(1.2,0.9,1.8); controls.target.set(0,0,0); controls.update(); }
    }

    // Шрифт для 3D-тексту
    const fontLoader = new FontLoader();
    let font = null;
    fontLoader.load(
      'https://cdn.jsdelivr.net/npm/three@0.159/examples/fonts/helvetiker_regular.typeface.json',
      f => font = f,
      undefined,
      err => console.warn('Шрифт не завантажився:', err)
    );

    // Завантаження STL
    const stlLoader = new STLLoader();
    function clearGroup(grp){
      while(grp.children.length){
        const m = grp.children.pop();
        m.geometry?.dispose?.(); m.material?.dispose?.();
      }
    }
    function clearAll(){ clearGroup(modelRoot); clearGroup(watermarkGroup); statusEl.textContent=''; }
    function addGeometry(geometry){
      geometry.computeVertexNormals?.();
      const mesh = new THREE.Mesh(geometry, wireframeOn ? wireMaterial : baseMaterial);
      modelRoot.add(mesh);
      fitCameraToObject(modelRoot, 1.6);
      $('btnBake').disabled = false;
    }
    function loadSTLFromFile(file){
      const url = URL.createObjectURL(file);
      stlLoader.load(url, (geom)=>{
        clearAll(); addGeometry(geom); URL.revokeObjectURL(url);
      }, undefined, (err)=>{
        console.error('STL load error:', err); alert('Не вдалося прочитати STL.');
      });
    }

    // Drag&Drop
    (()=>{
      const dz = $('viewer').parentElement;
      dz.addEventListener('dragover', e=>{e.preventDefault(); dz.style.outline='2px dashed #6c63ff';});
      ['dragleave','drop'].forEach(ev=>dz.addEventListener(ev, e=>{e.preventDefault(); dz.style.outline='none';}));
      dz.addEventListener('drop', e=>{
        const f = e.dataTransfer?.files?.[0];
        if (f && /\.stl$/i.test(f.name)) loadSTLFromFile(f);
      });
    })();

    // UI
    $('file').addEventListener('change', ()=>{ const f = $('file').files?.[0]; if (f) loadSTLFromFile(f); });
    $('btnDemo').addEventListener('click', ()=>{
      clearAll();
      const g = new THREE.BoxGeometry(50,30,20);
      addGeometry(g);
    });
    $('btnReset').addEventListener('click', resetCamera);
    $('btnWire').addEventListener('click', ()=>{
      wireframeOn = !wireframeOn;
      modelRoot.traverse(o=>{ if (o.isMesh) o.material = wireframeOn?wireMaterial:baseMaterial; });
    });
    $('btnClear').addEventListener('click', ()=>{ clearAll(); $('file').value=''; resetCamera(); });

    // Прев’ю 3D-водяного знаку
    function previewWatermark(){
      if (!font){ alert('Шрифт ще вантажиться. Спробуй за мить.'); return; }
      if (!modelRoot.children.length){ alert('Спершу завантаж модель.'); return; }
      clearGroup(watermarkGroup);

      const text = $('wmText').value.trim() || 'Brand';
      const size = +$('wmSize').value;
      const depth= +$('wmDepth').value;
      const angle= (+$('wmAngle').value * Math.PI/180);
      const offsetP = +$('wmOffset').value / 100;

      const tg = new TextGeometry(text, { font, size, height:depth, curveSegments:8, bevelEnabled:false });
      tg.computeBoundingBox();
      const mat = new THREE.MeshStandardMaterial({ color:0xff4488, transparent:true, opacity:.65 });
      const mesh = new THREE.Mesh(tg, mat);

      // позиція на верхній грані моделі
      const mbox = new THREE.Box3().setFromObject(modelRoot);
      const msize = mbox.getSize(new THREE.Vector3());
      const margin = msize.length() * offsetP;

      mesh.rotation.set(0,0,angle);
      mesh.position.set(mbox.min.x + margin, mbox.max.y + 0.1, mbox.min.z + margin);

      watermarkGroup.add(mesh);
      statusEl.textContent = 'Попередній перегляд знаку активний (рожевий обʼєкт).';
    }
    $('btnPreview').addEventListener('click', previewWatermark);

    // Запікання у геометрію (просте обʼєднання позицій)
    function bakeWatermark(){
      if (!watermarkGroup.children.length){ alert('Немає превʼю знаку. Натисни «Попередній перегляд».'); return; }
      const base = modelRoot.children.find(o=>o.isMesh);
      if (!base){ alert('Немає геометрії моделі.'); return; }

      const wm = watermarkGroup.children[0];
      wm.updateMatrixWorld(true);

      const baseGeo = base.geometry.clone();
      const wmGeo   = wm.geometry.clone().applyMatrix4(wm.matrixWorld);

      const aPos = baseGeo.getAttribute('position');
      const bPos = wmGeo.getAttribute('position');
      const pos  = new Float32Array(aPos.count*3 + bPos.count*3);
      pos.set(aPos.array, 0);
      pos.set(bPos.array, aPos.count*3);

      const merged = new THREE.BufferGeometry();
      merged.setAttribute('position', new THREE.BufferAttribute(pos, 3));
      merged.computeVertexNormals();

      base.geometry.dispose();
      base.geometry = merged;

      clearGroup(watermarkGroup);
      statusEl.textContent = 'Знак запечено у геометрію.';
    }
    $('btnBake').addEventListener('click', bakeWatermark);

    // Експорт
    const exporter = new STLExporter();
    function download(name, data, bin=false){
      const blob = new Blob([data], {type: bin? 'application/octet-stream':'text/plain'});
      const a = document.createElement('a');
      a.href = URL.createObjectURL(blob); a.download = name; a.click();
      URL.revokeObjectURL(a.href);
    }
    function exportSTL(isBinary){
      const mesh = modelRoot.children.find(o=>o.isMesh);
      if (!mesh){ alert('Немає моделі для експорту.'); return; }

      if (!isBinary){
        const addMeta = $('metaToggle').checked;
        const author = ($('author').value||'').replace(/\s+/g,' ').trim();
        const prev = mesh.name;
        mesh.name = addMeta && author ? `author=${author}` : (prev || 'model');
        const ascii = exporter.parse(mesh, {binary:false});
        mesh.name = prev;
        download((author?author.replaceAll(' ','_')+'_':'')+'model_ascii.stl', ascii, false);
      } else {
        const buf = exporter.parse(mesh, {binary:true});
        download('model_binary.stl', buf, true);
      }
    }
    $('btnExportAscii').addEventListener('click', ()=>exportSTL(false));
    $('btnExportBinary').addEventListener('click', ()=>exportSTL(true));

    // Рендер
    (function loop(){
      requestAnimationFrame(loop);
      controls.update();
      renderer.render(scene, camera);
    })();
  </script>
</body>
</html>


