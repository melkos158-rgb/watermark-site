<!DOCTYPE html>
<html lang="uk">
<head>
  <meta charset="utf-8" />
  <title>Online Tools — STL/3D</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link rel="stylesheet" href="{{ url_for('static', filename='style.css') }}">

  <!-- Лише мінімальні стилі під вʼювер -->
  <style>
    /* контейнер під three.js */
    #viewer{
      width:100%;
      height:62vh;          /* адаптивно */
      min-height:420px;     /* щоб не стискався занадто */
      background:#111;
      border:1px solid #e1e5ee;
      border-radius:10px;
      overflow:hidden;
    }
    #viewer canvas{display:block;width:100%;height:100%;}
    .row{display:flex;gap:8px;flex-wrap:wrap}
    .hint{font-size:12px;color:#667085;margin-top:6px}
    hr{border:none;border-top:1px solid #e9ecf2;margin:10px 0}
  </style>

  <!-- importmap -->
  <script type="importmap">
  {
    "imports": {
      "three": "https://cdn.jsdelivr.net/npm/three@0.159/build/three.module.js",
      "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.159/examples/jsm/",
      "stl/loader": "https://cdn.jsdelivr.net/npm/three@0.159/examples/jsm/loaders/STLLoader.js",
      "stl/exporter": "https://cdn.jsdelivr.net/npm/three@0.159/examples/jsm/exporters/STLExporter.js",
      "font/loader": "https://cdn.jsdelivr.net/npm/three@0.159/examples/jsm/loaders/FontLoader.js",
      "text/geometry": "https://cdn.jsdelivr.net/npm/three@0.159/examples/jsm/geometries/TextGeometry.js",

      "gltf/loader": "https://cdn.jsdelivr.net/npm/three@0.159/examples/jsm/loaders/GLTFLoader.js",
      "obj/loader":  "https://cdn.jsdelivr.net/npm/three@0.159/examples/jsm/loaders/OBJLoader.js",
      "ply/loader":  "https://cdn.jsdelivr.net/npm/three@0.159/examples/jsm/loaders/PLYLoader.js",

      "gltf/exporter":"https://cdn.jsdelivr.net/npm/three@0.159/examples/jsm/exporters/GLTFExporter.js",
      "obj/exporter": "https://cdn.jsdelivr.net/npm/three@0.159/examples/jsm/exporters/OBJExporter.js",
      "ply/exporter": "https://cdn.jsdelivr.net/npm/three@0.159/examples/jsm/exporters/PLYExporter.js"
    }
  }
  </script>
</head>
<body>

 <!-- NAV -->
 {% include 'nav.html' %}

  <!-- Основна сітка -->
  <div class="layout">

    <!-- Ліва колонка -->
<div class="card side">
  <h2>Модель</h2>

  <label>STL/3D файл</label>
  <input id="file" type="file" accept=".stl,.obj,.ply,.gltf,.glb">
  <p class="help">Перетягни файл у перегляд або вибери тут.</p>

  <div class="row" style="margin-top:10px">
    <button id="btnDemo"  class="btn primary">Демо куб</button>
    <button id="btnReset" class="btn ghost">Ресет камери</button>
  </div>

  <div class="row">
    <button id="btnWire" class="btn ghost">Wireframe ON/OFF</button>
    <button id="btnClear" class="btn ghost">Очистити</button>
  </div>

  <p class="help">Керування: ЛКМ — обертати, колесо — зум, Shift+ЛКМ — панорамувати.</p>

  <hr>

  <!-- Трансформації -->
  <h3>Трансформації</h3>
  <div class="row">
    <button id="btnCenter" class="btn ghost">Центрувати + На стіл</button>
    <button id="btnAutoOrient" class="btn ghost">Автоорієнтація</button>
  </div>
  <label>Масштаб (%)</label>
  <div class="row">
    <input id="scalePct" type="number" min="1" max="1000" value="100" style="width:100px">
    <button id="btnScaleApply" class="btn ghost">Застосувати</button>
  </div>
  <label>Обертання (°)</label>
  <div class="row">
    <button data-rot="x-90" class="btn ghost rot">X ±90</button>
    <button data-rot="y-90" class="btn ghost rot">Y ±90</button>
    <button data-rot="z-90" class="btn ghost rot">Z ±90</button>
  </div>
  <div class="row">
    <button data-mirror="x" class="btn ghost mirror">Mirror X</button>
    <button data-mirror="y" class="btn ghost mirror">Mirror Y</button>
    <button data-mirror="z" class="btn ghost mirror">Mirror Z</button>
  </div>

  <hr>

  <!-- Slice -->
  <h3>Різати площиною</h3>
  <label>Висота (Y)</label>
  <input id="sliceY" type="range" min="-200" max="200" value="0">
  <label>Кут навколо X</label>
  <input id="sliceAx" type="range" min="-90" max="90" value="0">
  <label>Кут навколо Z</label>
  <input id="sliceAz" type="range" min="-90" max="90" value="0">
  <div class="row">
    <button id="btnSlicePreview" class="btn ghost">Прев’ю площини</button>
    <button id="btnSliceApply" class="btn ghost">Розрізати → 2 частини</button>
  </div>

  <hr>

  <!-- Boolean -->
  <h3>Boolean-операції</h3>
  <div class="row">
    <button data-prim="box" class="btn ghost prim">Куб</button>
    <button data-prim="cyl" class="btn ghost prim">Циліндр</button>
    <button data-prim="sph" class="btn ghost prim">Сфера</button>
  </div>
  <div class="row">
    <button id="btnUnion" class="btn ghost">Union</button>
    <button id="btnSubtract" class="btn ghost">Subtract</button>
    <button id="btnIntersect" class="btn ghost">Intersect</button>
  </div>

  <hr>

  <!-- Hollow -->
  <h3>Hollow (порожнина)</h3>
  <label>Товщина стінки (мм)</label>
  <input id="hollowWall" type="number" min="0.6" max="5" step="0.2" value="1.2" style="width:110px">
  <div class="row">
    <button id="btnHollow" class="btn ghost">Зробити порожнистою</button>
  </div>
  <label>Отвори для повітря</label>
  <div class="row">
    <button data-vent="3" class="btn ghost vent">Ø3 мм</button>
    <button data-vent="5" class="btn ghost vent">Ø5 мм</button>
    <button data-vent="8" class="btn ghost vent">Ø8 мм</button>
  </div>

  <hr>

  <!-- Гравірування -->
  <h3>Гравірування / Тиснення</h3>
  <div class="row">
    <button id="btnEngraveText" class="btn ghost">Текст</button>
    <button id="btnEngravePNG" class="btn ghost">PNG-логотип</button>
  </div>

  <hr>

  <!-- Simplify -->
  <h3>Simplify / Decimate</h3>
  <label>Залишити % трикутників</label>
  <input id="simpKeep" type="range" min="5" max="100" value="60">
  <div class="row">
    <button id="btnSimplify" class="btn ghost">Спрощення</button>
  </div>

  <hr>

  <!-- Mix&Match -->
  <h3>Mix & Match</h3>
  <input id="addFile" type="file" accept=".stl,.obj,.ply,.gltf,.glb">
  <div class="row" style="margin-top:6px">
    <button id="btnUnionAll" class="btn ghost">Union всіх</button>
  </div>
</div>

    <!-- Центр -->
  <div class="card">  
    <h2>Перегляд</h2> 
    <div id="viewer">
    </div> <div class="hint" id="status"></div>
  </div>

    <!-- Права колонка -->
    <div class="card side">
      <h2>Авторство</h2>

      <label for="author">Автор (для ASCII STL)</label>
      <input id="author" type="text" placeholder="© My Brand" value="© My Brand">

      <label style="margin-top:8px">
        <input id="metaToggle" type="checkbox" checked>
        Додавати «змінне» авторство у назву <code>solid</code> (ASCII STL)
      </label>

      <hr>

      <h2 style="margin-top:0">3D водяний знак</h2>

      <label for="wmText">Текст</label>
      <input id="wmText" type="text" placeholder="Brand" value="Brand">

      <label for="wmSize">Розмір тексту</label>
      <input id="wmSize" type="range" min="2" max="40" value="12">

      <label for="wmDepth">Глибина (мм)</label>
      <input id="wmDepth" type="range" min="1" max="10" value="3">

      <label for="wmAngle">Кут (°)</label>
      <input id="wmAngle" type="range" min="-90" max="90" value="0">

      <label for="wmOffset">Відступ від країв (%)</label>
      <input id="wmOffset" type="range" min="0" max="20" value="4">

      <div class="row" style="margin-top:8px">
        <button id="btnPreview" class="btn ghost">Попередній перегляд</button>
        <button id="btnBake" class="btn ghost" disabled>Запекти в модель</button>
      </div>

      <hr>

      <div class="row">
        <button id="btnExportAscii" class="btn primary">Експорт STL (ASCII)</button>
        <button id="btnExportBinary" class="btn ghost">Експорт STL (Binary)</button>
      </div>

      <h3 style="margin-top:12px">Конвертація / Експорт</h3>
      <div class="row">
        <button id="btnExpGLB"  class="btn ghost">Export GLB</button>
        <button id="btnExpGLTF" class="btn ghost">Export GLTF</button>
      </div>
      <div class="row">
        <button id="btnExpOBJ"  class="btn ghost">Export OBJ</button>
        <button id="btnExpPLY"  class="btn ghost">Export PLY</button>
      </div>

      <p class="help">Файли обробляються локально в браузері. Підтримка імпорту: STL, OBJ, PLY, glTF/GLB.</p>
    </div>
  </div>

  <!-- JS -->
  <script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
    import { STLLoader }     from 'stl/loader';
    import { STLExporter }   from 'stl/exporter';
    import { FontLoader }    from 'font/loader';
    import { TextGeometry }  from 'text/geometry';

    import { GLTFLoader }    from 'gltf/loader';
    import { OBJLoader }     from 'obj/loader';
    import { PLYLoader }     from 'ply/loader';

    import { GLTFExporter }  from 'gltf/exporter';
    import { OBJExporter }   from 'obj/exporter';
    import { PLYExporter }   from 'ply/exporter';

    const $ = (id)=>document.getElementById(id);
    const statusEl = $('status');

    // Сцена
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x111111);

    const camera = new THREE.PerspectiveCamera(50, 1, 0.01, 1000);
    camera.position.set(1.2, 0.9, 1.8);

    const renderer = new THREE.WebGLRenderer({ antialias:true });
    renderer.outputColorSpace = THREE.SRGBColorSpace;
    renderer.setPixelRatio(Math.min(window.devicePixelRatio||1, 2));
    $('viewer').appendChild(renderer.domElement);

    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;

    // Світло + сітка
    scene.add(new THREE.AmbientLight(0xffffff, 0.7));
    const dir = new THREE.DirectionalLight(0xffffff, 0.9);
    dir.position.set(2,2,2); scene.add(dir);
    const grid = new THREE.GridHelper(10, 10, 0x3a4153, 0x262b39);
    grid.position.y = -0.001; scene.add(grid);

    // Групи
    const modelRoot = new THREE.Group(); scene.add(modelRoot);
    const watermarkGroup = new THREE.Group(); scene.add(watermarkGroup);

    // Матеріали
    const baseMaterial = new THREE.MeshStandardMaterial({ color:0x9aa7c7, roughness:.85, metalness:.05 });
    const wireMaterial = new THREE.MeshBasicMaterial({ color:0xffffff, wireframe:true });
    let wireframeOn = false;

    // Ресайз
    function resize(){
      const cont = $('viewer');
      const w = cont.clientWidth || cont.parentElement.clientWidth || 800;
      const h = cont.clientHeight || Math.max(420, Math.round(w*0.62));
      renderer.setSize(w,h,false);
      camera.aspect = w/h;
      camera.updateProjectionMatrix();
    }
    new ResizeObserver(resize).observe($('viewer')); window.addEventListener('resize', resize); resize();

    function fitCameraToObject(object, zoom=1.6){
      const box = new THREE.Box3().setFromObject(object);
      const size = box.getSize(new THREE.Vector3());
      const center = box.getCenter(new THREE.Vector3());
      const maxDim = Math.max(size.x, size.y, size.z) || 1;
      const fov = camera.fov * (Math.PI/180);
      let camZ = Math.abs(maxDim / (2*Math.tan(fov/2))) * zoom;
      camZ = Math.max(camZ, 0.1);
      camera.position.set(center.x+camZ*0.7, center.y+camZ*0.5, center.z+camZ);
      camera.near = camZ/100; camera.far = camZ*100; camera.updateProjectionMatrix();
      controls.target.copy(center); controls.update();
    }
    function resetCamera(){
      if (modelRoot.children.length) fitCameraToObject(modelRoot, 1.6);
      else { camera.position.set(1.2,0.9,1.8); controls.target.set(0,0,0); controls.update(); }
    }

    // Шрифт
    const fontLoader = new FontLoader();
    let font = null;
    fontLoader.load(
      'https://cdn.jsdelivr.net/npm/three@0.159/examples/fonts/helvetiker_regular.typeface.json',
      f => font = f,
      undefined,
      err => console.warn('Шрифт не завантажився:', err)
    );

    // Лоадери
    const stlLoader  = new STLLoader();
    const gltfLoader = new GLTFLoader();
    const objLoader  = new OBJLoader();
    const plyLoader  = new PLYLoader();

    function clearGroup(grp){
      while(grp.children.length){
        const m = grp.children.pop();
        m.geometry?.dispose?.(); m.material?.dispose?.();
      }
    }
    function clearAll(){ clearGroup(modelRoot); clearGroup(watermarkGroup); statusEl.textContent=''; }

    function addGeometry(geometry){
      geometry.computeVertexNormals?.();
      const mesh = new THREE.Mesh(geometry, wireframeOn ? wireMaterial : baseMaterial);
      modelRoot.add(mesh);
      fitCameraToObject(modelRoot, 1.6);
      $('btnBake').disabled = false;
    }

    function addObject(obj){
      obj.traverse(n=>{
        if(n.isMesh){
          n.material = wireframeOn ? wireMaterial : baseMaterial.clone();
          n.material.side = THREE.DoubleSide;
          n.geometry?.computeVertexNormals?.();
        }
      });
      modelRoot.add(obj);
      const box = new THREE.Box3().setFromObject(modelRoot);
      const center = box.getCenter(new THREE.Vector3());
      const minY = box.min.y;
      modelRoot.position.sub(center);
      modelRoot.position.y -= minY;
      fitCameraToObject(modelRoot, 1.6);
      $('btnBake').disabled = true;
    }

    function loadSTLFromFile(file){
      const url = URL.createObjectURL(file);
      stlLoader.load(url, (geom)=>{
        clearAll(); addGeometry(geom); URL.revokeObjectURL(url);
      }, undefined, (err)=>{
        console.error('STL load error:', err); alert('Не вдалося прочитати STL.');
      });
    }

    // Універсальне завантаження
    function loadAnyFromFile(file){
      const ext = file.name.split('.').pop().toLowerCase();
      const url = URL.createObjectURL(file);

      const done = ()=> URL.revokeObjectURL(url);

      const onError = (err)=>{
        console.error('Load error:', err);
        alert('Не вдалося прочитати файл. Підтримка: STL, OBJ, PLY, glTF/GLB.');
        done();
      };

      if (ext === 'stl'){
        stlLoader.load(url, (geom)=>{ clearAll(); addGeometry(geom); done(); }, undefined, onError);
      } else if (ext === 'obj'){
        objLoader.load(url, (obj)=>{ clearAll(); addObject(obj); done(); }, undefined, onError);
      } else if (ext === 'ply'){
        plyLoader.load(url, (geom)=>{ geom.computeVertexNormals(); clearAll(); addGeometry(geom); done(); }, undefined, onError);
      } else if (ext === 'gltf' || ext === 'glb'){
        gltfLoader.load(url, (gltf)=>{ clearAll(); addObject(gltf.scene); done(); }, undefined, onError);
      } else {
        alert('Формат не підтримується (доступні: STL, OBJ, PLY, glTF/GLB).');
        done();
      }
    }

    // Drag&Drop
    (()=>{
      const dz = $('viewer').parentElement;
      dz.addEventListener('dragover', e=>{e.preventDefault(); dz.style.outline='2px dashed #6c63ff';});
      ['dragleave','drop'].forEach(ev=>dz.addEventListener(ev, e=>{e.preventDefault(); dz.style.outline='none';}));
      dz.addEventListener('drop', e=>{
        const f = e.dataTransfer?.files?.[0];
        if (!f) return;
        if (/\.(stl|obj|ply|gltf|glb)$/i.test(f.name)) loadAnyFromFile(f);
        else alert('Підтримка: STL, OBJ, PLY, glTF/GLB.');
      });
    })();

    // UI
    $('file').addEventListener('change', ()=>{
      const f = $('file').files?.[0];
      if (f) loadAnyFromFile(f);
    });
    $('btnDemo').addEventListener('click', ()=>{
      clearAll();
      const g = new THREE.BoxGeometry(50,30,20);
      addGeometry(g);
    });
    $('btnReset').addEventListener('click', resetCamera);
    $('btnWire').addEventListener('click', ()=>{
      wireframeOn = !wireframeOn;
      modelRoot.traverse(o=>{ if (o.isMesh) o.material = wireframeOn?wireMaterial:baseMaterial; });
    });
    $('btnClear').addEventListener('click', ()=>{ clearAll(); $('file').value=''; resetCamera(); });

    // Водяний знак
    function previewWatermark(){
      if (!font){ alert('Шрифт ще вантажиться. Спробуй за мить.'); return; }
      if (!modelRoot.children.length){ alert('Спершу завантаж модель.'); return; }
      clearGroup(watermarkGroup);

      const text = $('wmText').value.trim() || 'Brand';
      const size = +$('wmSize').value;
      const depth= +$('wmDepth').value;
      const angle= (+$('wmAngle').value * Math.PI/180);
      const offsetP = +$('wmOffset').value / 100;

      const tg = new TextGeometry(text, { font, size, height:depth, curveSegments:8, bevelEnabled:false });
      tg.computeBoundingBox();
      const mat = new THREE.MeshStandardMaterial({ color:0xff4488, transparent:true, opacity:.65 });
      const mesh = new THREE.Mesh(tg, mat);

      const mbox = new THREE.Box3().setFromObject(modelRoot);
      const msize = mbox.getSize(new THREE.Vector3());
      const margin = msize.length() * offsetP;

      mesh.rotation.set(0,0,angle);
      mesh.position.set(mbox.min.x + margin, mbox.max.y + 0.1, mbox.min.z + margin);

      watermarkGroup.add(mesh);
      statusEl.textContent = 'Попередній перегляд знаку активний (рожевий обʼєкт).';
    }
    $('btnPreview').addEventListener('click', previewWatermark);

    function bakeWatermark(){
      if (!watermarkGroup.children.length){ alert('Немає превʼю знаку. Натисни «Попередній перегляд».'); return; }
      const base = modelRoot.children.find(o=>o.isMesh);
      if (!base){ alert('Немає геометрії моделі.'); return; }

      const wm = watermarkGroup.children[0];
      wm.updateMatrixWorld(true);

      const baseGeo = base.geometry.clone();
      const wmGeo   = wm.geometry.clone().applyMatrix4(wm.matrixWorld);

      const aPos = baseGeo.getAttribute('position');
      const bPos = wmGeo.getAttribute('position');
      const pos  = new Float32Array(aPos.count*3 + bPos.count*3);
      pos.set(aPos.array, 0);
      pos.set(bPos.array, aPos.count*3);

      const merged = new THREE.BufferGeometry();
      merged.setAttribute('position', new THREE.BufferAttribute(pos, 3));
      merged.computeVertexNormals();

      base.geometry.dispose();
      base.geometry = merged;

      clearGroup(watermarkGroup);
      statusEl.textContent = 'Знак запечено у геометрію.';
    }
    $('btnBake').addEventListener('click', bakeWatermark);

    // Експорт STL
    const stlExporter = new STLExporter();
    function download(name, data, bin=false){
      const blob = new Blob([data], {type: bin? 'application/octet-stream':'text/plain'});
      const a = document.createElement('a');
      a.href = URL.createObjectURL(blob); a.download = name; a.click();
      URL.revokeObjectURL(a.href);
    }
    function exportSTL(isBinary){
      const mesh = modelRoot.children.find(o=>o.isMesh);
      if (!mesh){ alert('Немає моделі для експорту.'); return; }

      if (!isBinary){
        const addMeta = $('metaToggle').checked;
        const author = ($('author').value||'').replace(/\s+/g,' ').trim();
        const prev = mesh.name;
        mesh.name = addMeta && author ? `author=${author}` : (prev || 'model');  <!-- ЄДИНА ПРАВКА -->
        const ascii = stlExporter.parse(mesh, {binary:false});
        mesh.name = prev;
        download((author?author.replaceAll(' ','_')+'_':'')+'model_ascii.stl', ascii, false);
      } else {
        const buf = stlExporter.parse(mesh, {binary:true});
        download('model_binary.stl', buf, true);
      }
    }
    $('btnExportAscii').addEventListener('click', ()=>exportSTL(false));
    $('btnExportBinary').addEventListener('click', ()=>exportSTL(true));

    // Підготовка та експорт у GLB/GLTF/OBJ/PLY
    function getExportGroup(){
      if(!modelRoot || modelRoot.children.length===0){ alert('Нема моделі'); return null; }
      const group = new THREE.Group();
      modelRoot.updateMatrixWorld(true);
      modelRoot.traverse(n=>{
        if(n.isMesh && n.geometry){
          const g = n.geometry.clone();
          g.applyMatrix4(n.matrixWorld);
          group.add(new THREE.Mesh(g));
        }
      });
      if(!group.children.length){ alert('Нема сітки'); return null; }
      return group;
    }
    function exportGLB(){
      const root = getExportGroup(); if(!root) return;
      const ex = new GLTFExporter();
      ex.parse(root, (bin)=>{ download('model.glb', bin, true); }, { binary:true, onlyVisible:true, trs:false });
    }
    function exportGLTF(){
      const root = getExportGroup(); if(!root) return;
      const ex = new GLTFExporter();
      ex.parse(root, (gltf)=>{ download('model.gltf', JSON.stringify(gltf), false); }, { binary:false, onlyVisible:true, trs:false, embedImages:true });
    }
    function exportOBJ(){
      const root = getExportGroup(); if(!root) return;
      const ex = new OBJExporter();
      const text = ex.parse(root);
      download('model.obj', text, false);
    }
    function exportPLY(){
      const root = getExportGroup(); if(!root) return;
      const ex = new PLYExporter();
      const text = ex.parse(root);
      download('model.ply', text, false);
    }
    $('btnExpGLB') .addEventListener('click', exportGLB);
    $('btnExpGLTF').addEventListener('click', exportGLTF);
    $('btnExpOBJ') .addEventListener('click', exportOBJ);
    $('btnExpPLY') .addEventListener('click', exportPLY);

    // Рендер
    (function loop(){
      requestAnimationFrame(loop);
      controls.update();
      renderer.render(scene, camera);
    })();
  </script>
</body>
</html>


