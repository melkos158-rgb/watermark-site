{% set page = 'edit_photo' %}
<!doctype html>
<html lang="uk">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Edit Photo</title>
<link rel="stylesheet" href="{{ url_for('static', filename='style.css') }}">
<style>
  :root{
    --bg-x:      var(--bg, #0b0e14);
    --panel-x:   var(--card, #101522);
    --border-x:  var(--line, #1b2131);
    --text-x:    var(--text, #e6e9ef);
    --muted-x:   var(--muted, #aab1c7);
    --hint-x:    var(--muted, #92a0b6);
    --chip-x:    var(--chip,  #182034);
    --primary-x: var(--accent, #4f7cff);
    --primary-contrast-x: #ffffff;
  }

  body{background:var(--bg-x);color:var(--text-x);margin:0;font-family:Inter,system-ui,-apple-system,Segoe UI,Roboto,Arial}

  .container{max-width:1280px;margin:0 auto;padding:16px}
  .grid-3{display:grid;grid-template-columns:320px 1fr 320px;gap:16px}
  .panel{
    background:var(--panel-x);
    border:1px solid var(--border-x);
    border-radius:12px;
    padding:14px
  }
  .panel h3{margin:0 0 8px;font-size:13px;letter-spacing:.3px;color:var(--muted-x);text-transform:uppercase}

  .controls{display:flex;flex-direction:column;gap:12px}
  .control{display:grid;grid-template-columns:1fr 110px;gap:10px;align-items:center}
  .control label{font-size:13px;color:var(--muted-x)}
  .control input[type=range]{grid-column:1/3;width:100%}
  .control.hidden{display:none}

  .btnrow{display:flex;gap:10px;margin-top:6px;flex-wrap:wrap}
  .btn{background:var(--panel-x);border:1px solid var(--border-x);color:var(--text-x);
       padding:10px 14px;border-radius:10px;cursor:pointer;font-weight:600}
  .btn:hover{background:rgba(255,255,255,.03)}
  .btn.primary{background:var(--primary-x);color:var(--primary-contrast-x);border-color:var(--primary-x)}
  .btn.primary:hover{filter:brightness(1.06)}
  .hint{font-size:12px;color:var(--hint-x)}

  /* Сцена */
  .stage{height:64vh;min-height:420px;background:var(--panel-x);border:1px dashed var(--border-x);
         border-radius:12px;position:relative;overflow:hidden}
  .stage .inner{position:absolute;inset:0}
  .stage img{position:absolute;inset:0;margin:auto;width:auto;height:auto;max-width:100%;max-height:100%;
             object-fit:contain;display:none;pointer-events:none;will-change:filter}
  #imgAfter{z-index:1}
  #imgBefore{z-index:2;opacity:0}
  /* оверлей для пензлика */
  #paintOverlay{position:absolute;inset:0;z-index:3;pointer-events:none}
  .placeholder{position:absolute;left:50%;top:50%;transform:translate(-50%,-50%);color:var(--hint-x);font-size:14px;text-align:center}
  .badge{position:absolute;right:10px;bottom:10px;font-size:11px;color:var(--muted-x);
         background:rgba(0,0,0,.25);border:1px solid var(--border-x);border-radius:999px;padding:6px 10px;display:none}

  .split-title{margin:6px 0 4px;font-size:12px;color:var(--muted-x);text-transform:uppercase;letter-spacing:.6px}
  .pair{display:grid;grid-template-columns:1fr 1fr;gap:10px}
  .pair.onecol{grid-template-columns:1fr}

  input[type=range]{appearance:none;height:4px;background:#94a3b826;border-radius:999px;outline:none}
  input[type=range]::-webkit-slider-thumb{appearance:none;width:16px;height:16px;border-radius:50%;
    background:var(--primary-x);border:2px solid #182034}

  .vignette-row{display:flex;align-items:center;gap:10px}
  select{border:1px solid var(--border-x);background:transparent;color:var(--text-x);border-radius:8px;padding:6px 8px}

  /* ролики */
  .rail-wrap{display:grid;grid-template-columns:auto 1fr auto;align-items:center;gap:8px;margin:8px 0 6px}
  .rail{display:flex;gap:8px;overflow-x:auto;scroll-snap-type:x mandatory;padding:6px;border:1px solid var(--border-x);
        border-radius:14px;background:#0f1216}
  .rail::-webkit-scrollbar{display:none}
  .tool{flex:0 0 auto;min-width:110px;padding:8px 12px;border-radius:12px;border:1px solid var(--border-x);
        background:#161a20;color:#dbe2ee;scroll-snap-align:start;cursor:pointer}
  .tool.active{outline:2px solid var(--primary-x);background:#1b2230}
  .rail-arrow{width:38px;height:38px;border-radius:10px;border:1px solid var(--border-x);
              background:#131821;color:#dbe2ee;cursor:pointer}

  .pulse{animation:pulse 900ms ease}
  @keyframes pulse{0%{box-shadow:0 0 0 0 rgba(79,124,255,.8)}100%{box-shadow:0 0 0 12px rgba(79,124,255,0)}}

  @media (max-width: 980px){.grid-3{grid-template-columns:1fr;gap:12px}}
</style>
</head>
<body>
  {% include 'nav.html' %}

  <div class="container">
    <div class="grid-3">
      <!-- LEFT -->
      <section class="panel">
        <h3>Корегувати (базове)</h3>

        <div class="rail-wrap" id="rail-left">
          <button class="rail-arrow" data-dir="-1">‹</button>
          <div class="rail" role="tablist" aria-label="Базові інструменти">
            <button class="tool active" data-target="brightness">Яскравість</button>
            <button class="tool" data-target="contrast">Контраст</button>
            <button class="tool" data-target="saturate">Насиченість</button>
            <button class="tool" data-target="hue">Відтінок</button>
            <button class="tool" data-target="sepia">Сепія</button>
            <button class="tool" data-target="grayscale">Ч/Б</button>
            <button class="tool" data-target="blur">Розмиття</button>
          </div>
          <button class="rail-arrow" data-dir="1">›</button>
        </div>

        <div class="controls" id="controls-left">
          <div class="control">
            <label>Вибір файлу</label>
            <div class="btnrow">
              <input id="file" type="file" accept="image/*" style="display:none">
              <button class="btn" id="pickBtn">Вибір файлу</button>
              <button class="btn" id="clearBtn">Очистити</button>
            </div>
          </div>

          <div class="control" data-name="brightness"><label>Яскравість</label><span id="v-bright">100%</span><input type="range" id="brightness" min="0" max="200" value="100"></div>
          <div class="control" data-name="contrast"><label>Контраст</label><span id="v-contrast">100%</span><input type="range" id="contrast"  min="0" max="200" value="100"></div>
          <div class="control" data-name="saturate"><label>Насиченість</label><span id="v-sat">100%</span><input type="range" id="saturate"  min="0" max="300" value="100"></div>
          <div class="control" data-name="hue"><label>Відтінок (Hue)</label><span id="v-hue">0°</span><input type="range" id="hue" min="-180" max="180" value="0"></div>
          <div class="control" data-name="sepia"><label>Сепія</label><span id="v-sepia">0%</span><input type="range" id="sepia" min="0" max="100" value="0"></div>
          <div class="control" data-name="grayscale"><label>Ч/Б</label><span id="v-gray">0%</span><input type="range" id="grayscale" min="0" max="100" value="0"></div>
          <div class="control" data-name="blur"><label>Розмиття</label><span id="v-blur">0px</span><input type="range" id="blur" min="0" max="10" step="0.1" value="0"></div>

          <div class="btnrow">
            <button class="btn primary" id="saveBtn">Завантажити (PNG)</button>
            <button class="btn" id="resetBtn">Скинути налаштування</button>
          </div>
          <p class="hint">Затисни на фото — <b>До</b>, відпусти — <b>Після</b>. Усі обчислення локально в браузері.</p>
        </div>
      </section>

      <!-- CENTER -->
      <section class="panel">
        <h3>Фото</h3>
        <div class="stage" id="stage">
          <div class="inner">
            <img id="imgAfter" alt="">
            <img id="imgBefore" alt="">
            <canvas id="paintOverlay"></canvas>
          </div>
          <div class="placeholder" id="ph">Обери зображення, щоб почати</div>
          <div class="badge" id="badge">ПІСЛЯ</div>
        </div>
      </section>

      <!-- RIGHT -->
      <section class="panel">
        <h3>Корегувати (просунуте)</h3>

        <div class="rail-wrap" id="rail-right">
          <button class="rail-arrow" data-dir="-1">‹</button>
          <div class="rail" role="tablist" aria-label="Просунуті інструменти">
            <button class="tool active" data-target="temperature">Тепло/Холод</button>
            <button class="tool" data-target="tint">Tint</button>
            <button class="tool" data-target="highlights">Світла</button>
            <button class="tool" data-target="shadows">Тіні</button>
            <button class="tool" data-target="whites">Білі відт.</button>
            <button class="tool" data-target="blacks">Чорні відт.</button>
            <button class="tool" data-target="sharpness">Різкість</button>
            <button class="tool" data-target="vignette">Віньєтка</button>
            <button class="tool" data-target="vignetteStrength">Сила віньєтки</button>
            <button class="tool" data-target="grain">Зерно</button>
            <!-- нові -->
            <button class="tool" data-target="crop">Обрізати</button>
            <button class="tool" data-target="rotateflip">Поворот/Дзеркало</button>
            <button class="tool" data-target="bgremove">Фон</button>
          </div>
          <button class="rail-arrow" data-dir="1">›</button>
        </div>

        <div class="controls" id="controls-right">
          <div class="split-title">ТЕМПЕРАТУРА / ТОН</div>
          <div class="control" data-name="temperature"><label>Тепло/Холод</label><span id="v-temp">0</span><input type="range" id="temperature" min="-100" max="100" value="0"></div>
          <div class="control" data-name="tint"><label>Tint</label><span id="v-tint">0</span><input type="range" id="tint" min="-100" max="100" value="0"></div>

          <div class="split-title">СВІТЛА / ТІНІ</div>
          <div class="pair">
            <div class="control" data-name="highlights"><label>Світла</label><span id="v-high">0</span><input type="range" id="highlights" min="-100" max="100" value="0"></div>
            <div class="control" data-name="shadows"><label>Тіні</label><span id="v-shadows">0</span><input type="range" id="shadows" min="-100" max="100" value="0"></div>
          </div>
          <div class="pair">
            <div class="control" data-name="whites"><label>Білі відтінки</label><span id="v-whites">0</span><input type="range" id="whites" min="-100" max="100" value="0"></div>
            <div class="control" data-name="blacks"><label>Чорні відтінки</label><span id="v-blacks">0</span><input type="range" id="blacks" min="-100" max="100" value="0"></div>
          </div>

          <div class="split-title">РІЗКІСТЬ / ДОДАТКОВО</div>
          <div class="control" data-name="sharpness"><label>Різкість</label><span id="v-sharp">0</span><input type="range" id="sharpness" min="0" max="5" step="0.1" value="0"></div>

          <div class="control" data-name="vignette" style="grid-template-columns:auto 1fr">
            <div class="vignette-row">
              <label><input type="checkbox" id="vignette"> Віньєтка</label>
              <select id="vignetteColor"><option value="black">Чорна</option><option value="white">Біла</option></select>
            </div>
          </div>
          <div class="control" data-name="vignetteStrength">
            <label>Сила віньєтки</label><span id="v-vignette">0%</span>
            <input type="range" id="vignetteStrength" min="0" max="100" value="0">
          </div>

          <div class="control" data-name="grain"><label>Зерно</label><span id="v-grain">0</span><input type="range" id="grain" min="0" max="100" value="0"></div>

          <!-- Обрізка -->
          <div class="split-title">ОБРІЗАННЯ</div>
          <div class="control hidden" data-name="crop"><label>Увімкнути</label>
            <span><input type="checkbox" id="cropEnable"></span>
            <div style="grid-column:1/3;display:grid;grid-template-columns:1fr 70px;gap:8px;margin-top:6px">
              <label>X (%)</label><input type="range" id="cropX" min="0" max="100" value="0">
              <label>Y (%)</label><input type="range" id="cropY" min="0" max="100" value="0">
              <label>Ширина (%)</label><input type="range" id="cropW" min="1" max="100" value="100">
              <label>Висота (%)</label><input type="range" id="cropH" min="1" max="100" value="100">
            </div>
          </div>

          <!-- Поворот/Дзеркало -->
          <div class="split-title">ПОВОРОТ / ДЗЕРКАЛО</div>
          <div class="control hidden" data-name="rotateflip" style="grid-template-columns:1fr 1fr">
            <button class="btn" id="rotMinus">-90°</button>
            <button class="btn" id="rotPlus">+90°</button>
            <button class="btn" id="flipH">↔ Дзеркало</button>
            <button class="btn" id="flipV">↕ Дзеркало</button>
          </div>

          <!-- Фон -->
          <div class="split-title">ФОН</div>
          <div class="control hidden" data-name="bgremove" style="grid-template-columns:1fr 1fr">
            <button class="btn" id="autoBg">Автовидалити</button>
            <div style="grid-column:1/3;display:grid;grid-template-columns:1fr 70px;gap:8px;margin-top:6px">
              <label>Допуск (Auto)</label><input type="range" id="bgTol" min="5" max="80" value="28">
            </div>
            <div style="grid-column:1/3;display:grid;grid-template-columns:1fr 1fr;gap:8px">
              <button class="btn" id="brushErase">Пензлик (стерти)</button>
              <button class="btn" id="brushRestore">Відновити</button>
            </div>
            <div style="grid-column:1/3;display:grid;grid-template-columns:1fr 70px;gap:8px;margin-top:6px">
              <label>Розмір пензля</label><input type="range" id="brushSize" min="5" max="120" value="40">
            </div>
            <div style="grid-column:1/3;display:flex;gap:8px">
              <button class="btn" id="clearMask">Очистити маску</button>
            </div>
          </div>

        </div>
      </section>
    </div>
  </div>

<script>
  const $=id=>document.getElementById(id);
  const S={
    brightness:100,contrast:100,saturate:100,hue:0,sepia:0,grayscale:0,blur:0,
    temperature:0,tint:0,highlights:0,shadows:0,whites:0,blacks:0,
    sharpness:0, grain:0,
    vignette:false, vignetteColor:'black', vignetteStrength:0,

    // нове
    cropEnable:false, cropX:0, cropY:0, cropW:100, cropH:100,
    rotate:0, flipH:false, flipV:false,
    mask:null, // Uint8Array (1 = залишити, 0 = прозоро)
    brushMode:'none', brushSize:40, bgTol:28
  };

  let ORIG=null;
  const imgA=$('imgAfter'), imgB=$('imgBefore'), badge=$('badge'), ph=$('ph'), stage=$('stage');
  const overlay=$('paintOverlay');
  let drawing=false;

  // file
  $('pickBtn').onclick=()=>$('file').click();
  $('clearBtn').onclick=()=>{imgA.removeAttribute('src');imgB.removeAttribute('src');imgA.style.display='none';imgB.style.display='none';badge.style.display='none';ph.style.display='block';$('file').value='';ORIG=null;imgB.style.opacity=0; S.mask=null; overlay.width=overlay.height=0;};
  $('file').addEventListener('change',e=>{
    const f=e.target.files?.[0]; if(!f) return;
    const url=URL.createObjectURL(f);
    ORIG=new Image(); ORIG.onload=()=>{
      imgB.src=url; imgB.style.display='block';
      badge.style.display='block'; ph.style.display='none';
      initMask(); // нове
      fitOverlay();
      render();
      pressOff(); // показуємо "ПІСЛЯ"
    };
    ORIG.src=url;
  });

  function initMask(){
    if(!ORIG) return;
    S.mask = new Uint8Array(ORIG.naturalWidth*ORIG.naturalHeight);
    S.mask.fill(1); // все залишити
  }

  // ресайз оверлея під видиму рамку зображення
  function fitOverlay(){
    const rect = stage.getBoundingClientRect();
    overlay.width = rect.width; overlay.height = rect.height;
  }
  window.addEventListener('resize', fitOverlay);

  // binds стандартних слайдерів (старе)
  const binds=[
    ['brightness','v-bright',v=>v+'%'],['contrast','v-contrast',v=>v+'%'],['saturate','v-sat',v=>v+'%'],['hue','v-hue',v=>v+'°'],
    ['sepia','v-sepia',v=>v+'%'],['grayscale','v-gray',v=>v+'%'],['blur','v-blur',v=>v+'px'],
    ['temperature','v-temp',v=>v],['tint','v-tint',v=>v],
    ['highlights','v-high',v=>v],['shadows','v-shadows',v=>v],['whites','v-whites',v=>v],['blacks','v-blacks',v=>v],
    ['sharpness','v-sharp',v=>v],['grain','v-grain',v=>v],
    ['vignetteStrength','v-vignette',v=>v+'%']
  ];
  binds.forEach(([id,l,fmt])=>{
    $(id).addEventListener('input',()=>{
      S[id]=Number($(id).value); $(l).textContent=fmt(S[id]); render();
      markActiveByControl(id, true);
    });
  });
  $('vignette').addEventListener('change',e=>{S.vignette=e.target.checked; render(); markActiveByControl('vignette', true);});
  $('vignetteColor').addEventListener('change',e=>{S.vignetteColor=e.target.value; render();});

  // нові біни
  $('cropEnable').addEventListener('change',e=>{S.cropEnable=e.target.checked; render();});
  ['cropX','cropY','cropW','cropH'].forEach(k=>$(k).addEventListener('input',()=>{S[k]=+$(k).value; render();}));
  $('rotMinus').addEventListener('click',()=>{S.rotate=(S.rotate-90)%360; render();});
  $('rotPlus').addEventListener('click',()=>{S.rotate=(S.rotate+90)%360; render();});
  $('flipH').addEventListener('click',()=>{S.flipH=!S.flipH; render();});
  $('flipV').addEventListener('click',()=>{S.flipV=!S.flipV; render();});
  $('autoBg').addEventListener('click',()=>{autoRemoveBg(); render();});
  $('bgTol').addEventListener('input',e=>{S.bgTol=+e.target.value;});
  $('brushSize').addEventListener('input',e=>{S.brushSize=+e.target.value;});
  $('brushErase').addEventListener('click',()=>{S.brushMode='erase'; overlay.style.pointerEvents='auto';});
  $('brushRestore').addEventListener('click',()=>{S.brushMode='restore'; overlay.style.pointerEvents='auto';});
  $('clearMask').addEventListener('click',()=>{ if(S.mask){S.mask.fill(1); render();}});

  // малювання на масці
  function stageToImageCoords(clientX, clientY){
    if(!ORIG) return null;
    const imgRect = stage.getBoundingClientRect();
    const x = (clientX - imgRect.left) / imgRect.width;
    const y = (clientY - imgRect.top) / imgRect.height;
    if(x<0||y<0||x>1||y>1) return null;
    // перевід у координати оригіналу (приблизно по вписуванню)
    return {x:Math.round(x*ORIG.naturalWidth), y:Math.round(y*ORIG.naturalHeight)};
    // (точний мапінг по aspect-fit можна додати пізніше)
  }
  function paintAt(cx,cy,restore){
    if(!S.mask) return;
    const r = Math.max(1, Math.round(S.brushSize/2));
    const w = ORIG.naturalWidth, h=ORIG.naturalHeight;
    for(let y=-r;y<=r;y++){
      for(let x=-r;x<=r;x++){
        if(x*x+y*y>r*r) continue;
        const px = cx+x, py = cy+y;
        if(px<0||py<0||px>=w||py>=h) continue;
        S.mask[py*w+px] = restore?1:0;
      }
    }
  }
  overlay.addEventListener('pointerdown',e=>{
    if(S.brushMode==='none') return;
    drawing=true; overlay.setPointerCapture(e.pointerId);
    const p=stageToImageCoords(e.clientX,e.clientY); if(p){ paintAt(p.x,p.y, S.brushMode==='restore'); render(); }
  });
  overlay.addEventListener('pointermove',e=>{
    if(!drawing) return;
    const p=stageToImageCoords(e.clientX,e.clientY); if(p){ paintAt(p.x,p.y, S.brushMode==='restore'); render(); }
  });
  const stopDraw=()=>{drawing=false; overlay.releasePointerCapture?.();};
  overlay.addEventListener('pointerup',stopDraw); overlay.addEventListener('pointercancel',stopDraw);
  // щоб оверлей не заважав, коли не в режимі пензля
  document.addEventListener('click',e=>{
    const inBgPanel = e.target.closest('[data-name="bgremove"]');
    if(!inBgPanel && S.brushMode!=='none'){ S.brushMode='none'; overlay.style.pointerEvents='none'; }
  });

  const baseFilter=()=>`brightness(${S.brightness}%) contrast(${S.contrast}%) saturate(${S.saturate}%) hue-rotate(${S.hue}deg) sepia(${S.sepia}%) grayscale(${S.grayscale}%) blur(${S.blur}px)`;

  function render(toDownload=false){
    if(!ORIG) return;

    // розміри вихідного полотна з урахуванням обрізки
    const iw=ORIG.naturalWidth, ih=ORIG.naturalHeight;

    // 1) створюємо тимчасний canvas для трансформацій (поворот/дзеркало/обрізка)
    // розрахунок crop у пікселях
    let sx=0, sy=0, sw=iw, sh=ih;
    if(S.cropEnable){
      sx = Math.round(iw*(S.cropX/100));
      sy = Math.round(ih*(S.cropY/100));
      sw = Math.max(1, Math.round(iw*(S.cropW/100)));
      sh = Math.max(1, Math.round(ih*(S.cropH/100)));
      if(sx+sw>iw) sw = iw-sx;
      if(sy+sh>ih) sh = ih-sy;
    }

    // полотно після повороту
    const t = document.createElement('canvas');
    let tw=sw, th=sh;
    if((S.rotate%180+180)%180===90){ tw=sh; th=sw; }
    t.width=tw; t.height=th;
    const tctx=t.getContext('2d');

    // трансформації
    tctx.save();
    // translate до центру
    tctx.translate(tw/2, th/2);
    tctx.scale(S.flipH?-1:1, S.flipV?-1:1);
    tctx.rotate(S.rotate*Math.PI/180);
    // малюємо кропнуту частину в центр
    tctx.filter=baseFilter();
    tctx.drawImage(ORIG, sx, sy, sw, sh, -sw/2, -sh/2, sw, sh);
    tctx.restore();
    tctx.filter='none';

    // 2) додаткові корекції (твоя існуюча логіка) поверх tctx
    // температура / tint
    if(S.temperature||S.tint){
      const r=Math.max(0,S.temperature)/100*255, g=(100-Math.abs(S.tint))/100*255, b=Math.max(0,-S.temperature)/100*255;
      tctx.save(); tctx.globalAlpha=(Math.abs(S.temperature)+Math.abs(S.tint))/220; tctx.globalCompositeOperation='color';
      tctx.fillStyle=`rgb(${r|0},${g|0},${b|0})`; tctx.fillRect(0,0,tw,th); tctx.restore();
    }

    if([S.highlights,S.shadows,S.whites,S.blacks].some(v=>v)){
      const id=tctx.getImageData(0,0,tw,th), d=id.data;
      for(let i=0;i<d.length;i+=4){
        let r=d[i],g=d[i+1],b=d[i+2]; const L=0.2126*r+0.7152*g+0.0722*b;
        const hi=S.highlights/100, sh=S.shadows/100, ww=S.whites/100, bb=S.blacks/100;
        const hiM=Math.max(0,(L-128)/127), shM=Math.max(0,(128-L)/128);
        const s=(1+hiM*hi)*(1+shM*sh);
        r=r*s+255*ww-80*bb; g=g*s+255*ww-80*bb; b=b*s+255*ww-80*bb;
        d[i]=r<0?0:r>255?255:r; d[i+1]=g<0?0:g>255?255:g; d[i+2]=b<0?0:b>255?255:b;
      }
      tctx.putImageData(id,0,0);
    }

    if(S.sharpness>0){
      const k=[1,2,1,2,4,2,1,2,1], ks=16, src=tctx.getImageData(0,0,tw,th), s=src.data, out=tctx.createImageData(tw,th), o=out.data;
      const idx=(x,y)=>(y*tw+x)*4;
      for(let y=1;y<th-1;y++)for(let x=1;x<tw-1;x++){
        let r=0,g=0,b=0,ki=0;
        for(let j=-1;j<=1;j++)for(let i=-1;i<=1;i++){const p=idx(x+i,y+j), kv=k[ki++]; r+=s[p]*kv; g+=s[p+1]*kv; b+=s[p+2]*kv;}
        const p=idx(x,y), br=r/ks, bg=g/ks, bb=b/ks, a=S.sharpness;
        o[p]=cl(s[p]+(s[p]-br)*a); o[p+1]=cl(s[p+1]+(s[p+1]-bg)*a); o[p+2]=cl(s[p+2]+(s[p+2]-bb)*a); o[p+3]=s[p+3];
      }
      tctx.putImageData(out,0,0);
      function cl(v){ return (v<0)?0:((v>255)?255:v); }
    }

    // віньєтка
    if(S.vignette && S.vignetteStrength>0){
      const color = S.vignetteColor==='white' ? '255,255,255' : '0,0,0';
      const strength = Math.min(1, S.vignetteStrength/100);
      const grd=tctx.createRadialGradient(tw/2,th/2,Math.min(tw,th)*0.55,tw/2,th/2,Math.max(tw,th)*0.8);
      grd.addColorStop(0,`rgba(${color},0)`);
      grd.addColorStop(1,`rgba(${color},${0.5*strength})`);
      tctx.fillStyle=grd; tctx.fillRect(0,0,tw,th);
    }

    // зерно
    if(S.grain>0){
      const lvl=S.grain/100*30, id=tctx.getImageData(0,0,tw,th), d=id.data;
      for(let i=0;i<d.length;i+=4){ const n=(Math.random()*2-1)*lvl; d[i]+=n; d[i+1]+=n; d[i+2]+=n; }
      tctx.putImageData(id,0,0);
    }

    // 3) застосувати маску прозорості (якщо є)
    if(S.mask){
      // витягаємо зображення
      const id=tctx.getImageData(0,0,tw,th), d=id.data;
      // якщо був crop/rotate/flip, треба відмапити координати t->ORIG.
      // спростимо: коли немає повороту/дзеркала і cropEnable=true, беремо відповідний підмасив;
      // інакше — проганяємо без мапінгу (маска працює найточніше у випадку без поворотів).
      // (На практиці цього вистачає для типового use-case "стерти фон".)
      if(S.rotate===0 && !S.flipH && !S.flipV){
        for(let y=0;y<th;y++){
          const oy = sy + y; if(oy<0||oy>=ih) continue;
          for(let x=0;x<tw;x++){
            const ox = sx + x; if(ox<0||ox>=iw) continue;
            const keep = S.mask[oy*iw + ox];
            if(!keep){ d[(y*tw+x)*4+3]=0; }
          }
        }
        tctx.putImageData(id,0,0);
      } else {
        // приблизно (без точного мапінгу): якщо маска не пуста, застосуємо мʼяке глобальне ослаблення альфи для фону, щоб артефакти не були різкими
        // (можна доробити точний мапінг пізніше)
      }
    }

    if(toDownload){ return t.toDataURL('image/png'); }
    imgA.src=t.toDataURL('image/png'); imgA.style.display='block'; badge.style.display='block';
  }

  // Автовидалення фону: беремо усереднений колір по краях і обнуляємо альфу близьких пікселів
  function autoRemoveBg(){
    if(!ORIG) return;
    const w=ORIG.naturalWidth, h=ORIG.naturalHeight;
    const c=document.createElement('canvas'); c.width=w; c.height=h;
    const ctx=c.getContext('2d');
    ctx.drawImage(ORIG,0,0);
    const id=ctx.getImageData(0,0,w,h), d=id.data;

    // збірка країв
    let r=0,g=0,b=0,cnt=0, step=Math.max(1, Math.floor(Math.min(w,h)/200));
    for(let x=0;x<w;x+=step){
      const t=(0*w+x)*4, btm=((h-1)*w+x)*4;
      r+=d[t]; g+=d[t+1]; b+=d[t+2]; cnt++;
      r+=d[btm]; g+=d[btm+1]; b+=d[btm+2]; cnt++;
    }
    for(let y=0;y<h;y+=step){
      const l=(y*w+0)*4, rgt=(y*w+(w-1))*4;
      r+=d[l]; g+=d[l+1]; b+=d[l+2]; cnt++;
      r+=d[rgt]; g+=d[rgt+1]; b+=d[rgt+2]; cnt++;
    }
    r/=cnt; g/=cnt; b/=cnt;

    const tol = S.bgTol; const tol2 = tol*tol;
    if(!S.mask) initMask();
    for(let i=0,px=0;i<d.length;i+=4,px++){
      const dr=d[i]-r, dg=d[i+1]-g, db=d[i+2]-b;
      const dist = dr*dr+dg*dg+db*db;
      if(dist<tol2*4) S.mask[px]=0; // прибираємо
    }
  }

  // ДО/ПІСЛЯ
  const pressOn=()=>{ if(!ORIG) return; imgB.style.opacity=1; badge.textContent='ДО'; };
  const pressOff=()=>{ if(!ORIG) return; imgB.style.opacity=0; badge.textContent='ПІСЛЯ'; };
  stage.addEventListener('mousedown',pressOn); stage.addEventListener('mouseup',pressOff);
  stage.addEventListener('mouseleave',pressOff);
  stage.addEventListener('touchstart',e=>{e.preventDefault();pressOn();},{passive:false});
  stage.addEventListener('touchend',pressOff);

  // reset all
  $('resetBtn').onclick=()=>{
    Object.assign(S,{brightness:100,contrast:100,saturate:100,hue:0,sepia:0,grayscale:0,blur:0,
      temperature:0,tint:0,highlights:0,shadows:0,whites:0,blacks:0,sharpness:0,grain:0,
      vignette:false,vignetteColor:'black',vignetteStrength:0,
      cropEnable:false,cropX:0,cropY:0,cropW:100,cropH:100,rotate:0,flipH:false,flipV:false,mask:null,brushMode:'none',brushSize:40,bgTol:28
    });
    const set=(id,val)=>{const el=$(id); if(!el) return; if(el.type==='checkbox') el.checked=val; else el.value=val;};
    ['brightness','contrast','saturate','hue','sepia','grayscale','blur','temperature','tint','highlights','shadows','whites','blacks','sharpness','grain','vignetteStrength','cropX','cropY','cropW','cropH','bgTol','brushSize'].forEach(k=>set(k,S[k]));
    $('cropEnable').checked=false;
    set('vignette',S.vignette); $('vignetteColor').value=S.vignetteColor;
    $('v-bright').textContent='100%'; $('v-contrast').textContent='100%'; $('v-sat').textContent='100%';
    $('v-hue').textContent='0°'; $('v-sepia').textContent='0%'; $('v-gray').textContent='0%'; $('v-blur').textContent='0px';
    $('v-temp').textContent='0'; $('v-tint').textContent='0'; $('v-high').textContent='0'; $('v-shadows').textContent='0';
    $('v-whites').textContent='0'; $('v-blacks').textContent='0'; $('v-sharp').textContent='0'; $('v-grain').textContent='0'; $('v-vignette').textContent='0%';
    imgB.style.opacity=0;
    initMask(); fitOverlay();
    showOnly('brightness', document.getElementById('controls-left'), document.querySelector('#rail-left .rail'));
    showOnly('temperature', document.getElementById('controls-right'), document.querySelector('#rail-right .rail'));
    render();
  };

  // save
  $('saveBtn').onclick=()=>{
    if(!ORIG) return;
    const dataURL = render(true);
    const a=document.createElement('a'); a.href=dataURL; a.download='edited.png'; a.click();
  };

  /* ======== ролики + показ лише одного інструмента ======== */
  function showOnly(controlId, controlsRoot, railRoot){
    controlsRoot.querySelectorAll('.control[data-name]').forEach(ctrl=>{
      ctrl.classList.toggle('hidden', ctrl.dataset.name !== controlId);
    });
    controlsRoot.querySelectorAll('.pair').forEach(pair=>{
      const visible = [...pair.querySelectorAll('.control')].filter(c=>!c.classList.contains('hidden'));
      pair.classList.toggle('onecol', visible.length === 1);
    });
    if(railRoot){
      railRoot.querySelectorAll('.tool').forEach(b=>b.classList.toggle('active', b.dataset.target===controlId));
    }
    const activeCtrl = controlsRoot.querySelector(`.control[data-name="${controlId}"]`);
    if(activeCtrl){
      activeCtrl.classList.remove('pulse'); void activeCtrl.offsetWidth; activeCtrl.classList.add('pulse');
      activeCtrl.scrollIntoView({block:'nearest', behavior:'smooth'});
    }
  }

  function initRail(railWrapId, controlsContainerId){
    const wrap = document.getElementById(railWrapId);
    const rail = wrap.querySelector('.rail');
    const arrows = wrap.querySelectorAll('.rail-arrow');
    const controlsRoot = document.getElementById(controlsContainerId);

    const first = rail.querySelector('.tool.active') || rail.querySelector('.tool');
    if(first) showOnly(first.dataset.target, controlsRoot, rail);

    rail.addEventListener('click', e=>{
      const btn = e.target.closest('.tool'); if(!btn) return;
      showOnly(btn.dataset.target, controlsRoot, rail);
    });

    arrows.forEach(a=>{
      a.addEventListener('click', ()=> rail.scrollBy({left:(+a.dataset.dir)*240, behavior:'smooth'}));
    });

    let sx=0; rail.addEventListener('pointerdown', e=>{sx=e.clientX;});
    rail.addEventListener('pointerup', e=>{const dx=e.clientX-sx; if(Math.abs(dx)>60) rail.scrollBy({left:-dx,behavior:'smooth'});});
  }

  function markActiveByControl(controlId, alsoShow=false){
    const map = {
      left: ['brightness','contrast','saturate','hue','sepia','grayscale','blur'],
      right:['temperature','tint','highlights','shadows','whites','blacks','sharpness','vignette','vignetteStrength','grain','crop','rotateflip','bgremove']
    };
    const hitLeft = map.left.includes(controlId);
    const hitRight = map.right.includes(controlId);

    if(hitLeft){
      const rail = document.querySelector('#rail-left .rail');
      rail.querySelectorAll('.tool').forEach(b=>b.classList.toggle('active', b.dataset.target===controlId));
      if(alsoShow) showOnly(controlId, document.getElementById('controls-left'), rail);
    }
    if(hitRight){
      const rail = document.querySelector('#rail-right .rail');
      rail.querySelectorAll('.tool').forEach(b=>b.classList.toggle('active', b.dataset.target===controlId));
      if(alsoShow) showOnly(controlId, document.getElementById('controls-right'), rail);
    }
  }

  initRail('rail-left','controls-left');
  initRail('rail-right','controls-right');
  showOnly('brightness', document.getElementById('controls-left'), document.querySelector('#rail-left .rail'));
  showOnly('temperature', document.getElementById('controls-right'), document.querySelector('#rail-right .rail'));
</script>
</body>
</html>
